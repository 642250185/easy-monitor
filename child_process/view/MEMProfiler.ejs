<script src="/docs/Chart.js"></script><!doctype html>
<html>
<head>
    <title>Easy-Monitor</title>
    <link href="/docs/styles.css" rel="stylesheet">
    <script src="/assets/jquery/jquery.min.js"></script>
    <script src="/docs/prettify.js"></script>
    <script src="/docs/Chart.js"></script>
    <script type="text/javascript">try {
            Typekit.load();
        } catch (e) {
        }</script>
    <script src="/echarts.min.js"></script>
</head>
<body>
<div class="redBorder"></div>
<div class="greenBorder"></div>
<div class="yellowBorder"></div>
<div id="wrapper">
    <nav>
        <dl>
        </dl>
    </nav>

    <div id="contentWrapper">
        <h1 id="mainHeader">Memory Leak</h1>
        <h2 id="introText"><a href="/MEMProfiler/<%- processName %>::<%- processPid %>">Pid:<%- processPid %></a>
            Heapnapshot Statistics By <a href="/">Easy-Monitor</a></h2>

        <article id="statistics">

            <h1>Heap Status</h1>
            <h2>Statistics</h2>
            <div id="statstics" style="width: 600px;height:400px;"></div>

            <h2>Summary</h2>
            <p>Heap Memory Total is: <%- helper.formatSize(statistics.total) %>, Below is summary sort by constructor name:</p>
            <%
                let aggregatesList = Object.keys(aggregates);
                let aggregatesLength = aggregatesList.length;
                //aggregatesList.sort((o, n)=>Number(aggregates[o].maxRet) < Number(aggregates[n].maxRet) ? 1 : -1);
                let longHtml = '<br />';
                let shortHtml = '<br />';
                let shortTag = '<a href="javascript:createAggregates()"><span class="rs-tag"><...Show All Aggregates></span></a>';

                for(let i = 0; i < aggregatesLength; i++){
                    let aggregate = aggregates[aggregatesList[i]];
                    let shallowSize = helper.formatSize(aggregate.self);
                    let retainedSize = helper.formatSize(aggregate.maxRet);
                    longHtml = longHtml + `${(i + 1)}. Constructor: "${aggregatesList[i]}", Distance: "${aggregate.distance>=1 && aggregate.distance || '-'}", Objects Count: "${aggregate.count}", Shallow Size: "${shallowSize}", Retained Size: "${retainedSize}"<br /><br />`;
                    if(i < 10) {
                        shortHtml = shortHtml + `${(i + 1)}. Constructor: "${aggregatesList[i]}", Distance: "${aggregate.distance >= 1 && aggregate.distance || '-'}", Objects Count: "${aggregate.count}", Shallow Size: "${shallowSize}", Retained Size: "${retainedSize}"<br /><br />`;
                    }

                    if(i === 10){
                        shortHtml = shortHtml + '<a href="javascript:createAggregates()"><span class="rs-tag">&lt;...Show All Aggregates &gt;</span></a>'
                    }

                    if(i === aggregatesLength - 1){
                        longHtml = longHtml+ '<a href="javascript:createAggregatesShort()"><span class="rs-tag">&lt;...Return Short Aggregates &gt;</span></a>'
                    }
                }
            %>
            <pre id="aggregates"><code><%- shortHtml %></code></pre>
        </article>


        <article id="LeakPoint">
            <h1>Memory Leak</h1>
            <h2>Suspicious Leak Point List</h2>
            <p>I think the most probable leak point can be things who take maximum heap memory.</p>
            <p>So I filter out the biggest <%- leak_limit %> nodes ( DESC by "RetainedSize" ): </p>
            <pre><code><%
                    let leakPointLength = leakPoint.length;
                    for(let i = 0; i < leakPointLength; i++){
                        let leak = leakPoint[i];
                    %>
<%- (i + 1) %>. name&id: "<%- heapMap[leak.index].name %>::<%- leak.id %>", distance:"<%- heapMap[leak.index].distance %>", type: "<%- heapMap[leak.index].type %>", retainedSize: "<%- leak.size %>bytes", taken "<%- ((leak.size / statistics.total) * 100).toFixed(2) %>%" of all heap memory.
                    <% } %></code></pre>
            <p>Below are gravity diagram, which can help you find leak point details.</p>

            <%
            for(let i = 0; i < leakPointLength; i++){
                let leak = leakPoint[i];
                let retainedSize = '';
                let sizeTmp = leak.size;
                if (sizeTmp / 1024 < 1) {
                    retainedSize = `${parseInt(sizeTmp)} Bytes`;
                } else if (sizeTmp / 1024 / 1024 < 1) {
                    retainedSize = `${parseInt(sizeTmp / 1024)} KB`;
                } else if (sizeTmp / 1024 / 1024 / 1024 < 1) {
                    retainedSize = `${parseInt(sizeTmp / 1024 / 1024)} MB`;
                } else {
                    retainedSize = `${parseInt(sizeTmp / 1024 / 1024 / 1024)} GB`;
                }
            %>
            <h2>Leak Point Detail: <%- leak.id %></h2>
            <p><%- heapMap[leak.index].name %>::<%- leak.id %>, it's retainSize is: <%- retainedSize %>, below is
                gravity diagram: </p>
            <div id="<%- leak.id %>" style="width: 800px;height:800px;"></div>
            <% } %>

        </article>
    </div>
</div>
</body>
<script>
    function createAggregates(){
        document.getElementById('aggregates').getElementsByTagName('code')[0].innerHTML = '<%- longHtml %>';
        prettyPrint();
    }

    function createAggregatesShort(){
        document.getElementById('aggregates').getElementsByTagName('code')[0].innerHTML = '<%- shortHtml %>';
        prettyPrint();
    }
</script>
<script>
    $(document).ready(function () {

        var $nav = $("nav dl");

        $("article").each(function () {
            var $el = $(this);
            var $h1 = $el.find("h1");
            var sectionTitle = $h1.html();
            var articleId = $el.attr("id");
            var $dt = $("<dt><a href=\"#" + articleId + "\">" + sectionTitle + "</a></dt>");

            $dt.find("a").on("click", function (e) {
                e.preventDefault();
                $('html,body').animate({scrollTop: $h1.offset().top}, 400);
            });


            $nav.append($dt);

            var $subtitles = $el.find("h2");

            $subtitles.each(function () {
                var $h2 = $(this);
                var title = $h2.text();
                var newID = articleId + "-" + camelCase(title);
                $h2.attr("id", newID);
                var $dd = $("<dd><a href=\"#" + newID + "\">" + title + "</a></dd>");

                $dd.find("a").on("click", function (e) {
                    e.preventDefault();
                    $('html,body').animate({scrollTop: $h2.offset().top}, 400);
                })
                $nav.append($dd);

            });

            var $articles = $el.find("article");

        });

        prettyPrint();

        function camelCase(str) {
            var splitString = str.split(" ");

            var returnedCamel = splitString[0].toLowerCase();

            for (var i = 1; i < splitString.length; i++) {
                returnedCamel += splitString[i].charAt(0).toUpperCase() + splitString[i].substring(1).toLowerCase();
            }

            return returnedCamel;

        }
    });
</script>
<script type="text/javascript">
    // 基于准备好的dom，初始化echarts实例
    var myChart = echarts.init(document.getElementById('statstics'));

    // 指定图表的配置项和数据
    var option = {
        title: {
            text: 'Pid:<%- processPid %>',
            subtext: 'HeapSnapshot Statistics',
            x: 'center'
        },
        tooltip: {
            trigger: 'item',
            formatter: "{a} <br/>{b} : {c} ({d}%)"
        },
        legend: {
            orient: 'vertical',
            left: 'left',
            data: []
        },
        series: [
            {
                name: 'HeapSnapshot',
                type: 'pie',
                radius: '55%',
                center: ['50%', '60%'],
                data: [],
                itemStyle: {
                    emphasis: {
                        shadowBlur: 10,
                        shadowOffsetX: 0,
                        shadowColor: 'rgba(0, 0, 0, 0.5)'
                    }
                }
            }
        ]
    };

    option.series[0].data = <%- JSON.stringify(Object.keys(statistics).reduce((pre, next) => {
        if (next !== 'total' && next !== 'v8heap') {
            pre.push({name: next, value: statistics[next]})
        }
        return pre;
    }, [])) %>

        option.legend.data = <%- JSON.stringify(Object.keys(statistics).filter(key => key !== 'total' && key !== 'v8heap')) %>// 使用刚指定的配置项和数据显示图表。
        myChart.setOption(option);
</script>
<script>
    var graphOptionsMap = {};
</script>
<%
for(let i = 0; i < leakPointLength; i++){
    let leak = leakPoint[i];
%>
<script type="text/javascript">
    // 基于准备好的dom，初始化echarts实例
    var myChart = echarts.init(document.getElementById('<%- leak.id %>'));

    // 指定图表的配置项和数据
    graphOptionsMap["<%- leak.id %>"] = {
        title: {
            text: '',
        },
        tooltip: {},
        animationDurationUpdate: 1500,
        animationEasingUpdate: 'quinticInOut',
        series: [
            {
                type: 'graph',
                layout: 'none',
                symbolSize: 50,
                roam: false,
                label: {
                    normal: {
                        show: true
                    }
                },
                edgeSymbol: ['circle', 'arrow'],
                edgeSymbolSize: [4, 10],
                edgeLabel: {
                    normal: {
                        textStyle: {
                            fontSize: 20
                        }
                    }
                },
                data: [],
                // links: [],
                links: [],
                lineStyle: {
                    normal: {
                        opacity: 0.9,
                        width: 2,
                        curveness: 0
                    }
                }
            }
        ]
    };

    <%
        /*let leakPointDetail = heapMap[leak.index];
        let leakDatas = [];
        let leakLinks = [];
        let linkLength = 2;

        let loopList = [leakPointDetail];
        let distance = 0;
        let distanceLimit = 1;
        while (loopList.length !== 0 && distance < distanceLimit) {
            let tmp = [];
            for (let i = 0; i < loopList.length; i++) {
                let children = loopList[i].children;

                children.sort((o, n) => {
                    let oldSize = Number(heapMap[o.index].retainedSize);
                    let newSize = Number(heapMap[n.index].retainedSize);

                    return oldSize < newSize ? 1 : -1;
                });

                children = children.filter((item, index) => index < 5);

                let fX = 0;
                let fY = 0;
                if(loopList[i].father){
                    let parentLocation = loopList[i].fatherLocation;
                    if(isNaN(parentLocation.x)){
                        parentLocation.x = 0;
                    }
                    if(isNaN(parentLocation.y)){
                        parentLocation.y = 0;
                    }

                    let allDegree = 90;
                    if(parentLocation.length > 2){
                        allDegree = 180;
                    }

                    if(parentLocation.length === 1){
                        fX = parentLocation.x + linkLength * Number(Math.cos(0));
                        fY = parentLocation.y + linkLength * Number(Math.sin(0));

                    }else{
                        fX = parentLocation.x + linkLength * Number(Math.cos(2 * Math.PI / 360 * allDegree/(parentLocation.length - 1) * parentLocation.index).toFixed(2));
                        fY = parentLocation.y + linkLength * Number(Math.sin(2 * Math.PI / 360 * allDegree/(parentLocation.length - 1) * parentLocation.index).toFixed(2));
                    }
                }

                leakDatas.push({name: `${loopList[i].id}`, x: fX, y: fY, value: loopList[i].retainedSize});


                children.forEach((child, index) => {
                    if (distance === (distanceLimit - 1)) {
                        let fX = 0;
                        let fY = 0;
                        if(heapMap[child.index].father){
                            let parentLocation = heapMap[child.index].fatherLocation;
                            parentLocation.x = isNaN(parentLocation.x) && 0 || parentLocation.x;
                            parentLocation.y = isNaN(parentLocation.y) && 0 || parentLocation.y;
                            let allDegree = 90;
                            if(parentLocation.length > 2){
                                allDegree = 180;
                            }

                            if(parentLocation.length === 1){
                                fX = parentLocation.x + linkLength * Number(Math.cos(0));
                                fY = parentLocation.y + linkLength * Number(Math.sin(0));

                            }else{
                                fX = parentLocation.x + linkLength * Number(Math.cos(2 * Math.PI / 360 * allDegree/(parentLocation.length - 1) * parentLocation.index).toFixed(2));
                                fY = parentLocation.y + linkLength * Number(Math.sin(2 * Math.PI / 360 * allDegree/(parentLocation.length - 1) * parentLocation.index).toFixed(2));
                            }
                        }

                        leakDatas.push({name: `${heapMap[child.index].id}`, x: fX, y: fY, value: heapMap[child.index].retainedSize});
                    }

                    leakLinks.push({
                        source: `${loopList[i].id}`,
                        target: `${heapMap[child.index].id}`,
                        label: {
                            normal: {
                                show: true,
                                formatter: `${String(child.name_or_index)}, ${((heapMap[child.index].retainedSize/loopList[i].retainedSize) * 100).toFixed(2)}%`
                            }
                        }
                    });

                    heapMap[child.index].father = loopList[i].index;
                    heapMap[child.index].fatherLocation = {x:fX, y:fY, length:children.length, index};
                    tmp.push(heapMap[child.index]);
                });
            }

            distance++;
            loopList = tmp;
        }

        console.log(leakPointDetail.id, JSON.stringify(leakDatas), JSON.stringify(leakLinks));*/
    %>

    <!--graphOptionsMap["<%- leak.id %>"].series[0].data = <%- /*JSON.stringify(leakDatas)*/ %>;-->
    <!--graphOptionsMap["<%- leak.id %>"].series[0].links = <%- /*JSON.stringify(leakLinks)*/ %>;-->

    // 使用刚指定的配置项和数据显示图表。
    myChart.setOption(graphOptionsMap["<%- leak.id %>"]);
</script>
<% } %>
</html>